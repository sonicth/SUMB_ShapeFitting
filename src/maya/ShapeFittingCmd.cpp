/*
 * copyright 2016 mike vasiljevs (contact@michaelvasiljevs.com)
 * ShapeFitting Maya plugin
 * 
 * Maya specific plugin coded handled here
 * 
 *   Load this module in Maya (Windows > Settings/Preferences >) Plug-in Manager by selecting path after clicking on Browse
 *
 *   Call plugin in MEL Script Editor window:
 *		fitShape <method>
 *		
 *	 where <method> is integer, as follows:
 *		0 - first four
 *		1 - bounding box
 *		
*/

#include "includes-maya.h"

using namespace std;
namespace dll = boost::dll;

// Debugger console writer
ConsoleWriter out;



// Macro for error checking
#define checkErr(STATUS, MESSAGE)          \
    if ( MS::kSuccess != STATUS ) {   \
        MGlobal::displayError(MString(MESSAGE) + ": " + STATUS.errorString());   \
        return STATUS;                \
    }


namespace Maya
{
	SoPtr_t fitter_lib;

	class ShapeFitting : public MPxCommand
	{

		int num_verts;
		int num_faces;
		MDagModifier dagMod;
		MFloatPointArray pa;
		MIntArray faceCounts;
		MIntArray faceConnects;

		int fit_method ;
		int box_type;//TODO get boxType from user

		MStatus fitShape(const MDagPath dagPath);
	public:
		MStatus doIt(const MArgList& args);
		
		static void* creator();
		ShapeFitting() {}
		virtual ~ShapeFitting() {}
	};

	MStatus getShapePts(MPointArray const &point_array, Pts_t &pts)
	{
		MStatus st;

		auto iregion_num_pts = point_array.length();
		pts.reserve(iregion_num_pts);

		for (int i = 0; i < iregion_num_pts; ++i)
		{
			Pts_t::value_type pt(point_array[i].x, point_array[i].z);
			pts.push_back(pt);
		}

		return st;
	}

	MStatus ShapeFitting::doIt(const MArgList& args)
	{
		fit_method = 0;
		box_type = 0;

		// first argument - fit method, second - box type
		if (args.length() > 0)
		{
			fit_method = args.asInt(0);

			if (args.length() > 1)
				box_type = args.asInt(1);
		}

		MStatus st;

		//create an iterator for the selected mesh components of the DAG
		//
		MSelectionList selectionList;
		st = MGlobal::getActiveSelectionList(selectionList);
		checkErr(st, "MGlobal::getActiveSelectionList");

		MItSelectionList itSelectionList(selectionList, MFn::kMesh, &st);
		checkErr(st, "Failed ct-ing selection iterator");


		for (itSelectionList.reset(); !itSelectionList.isDone(); itSelectionList.next()) 
		{
			MDagPath dagPath;
			//get the current dag path and process the poly mesh on it
			st = itSelectionList.getDagPath(dagPath);
			checkErr(st, "MItSelectionList::getDagPath");

			fitShape(dagPath);
			checkErr(st, "Shape Fitting failed!");
		}

		return MS::kSuccess;
	}

	////////////////////////////////////////////////////////////////
	// borrowed from polyPrimitiveCmd example!
	////////////////////////////////////////////////////////////////
	//-
	// ==========================================================================
	// Copyright (C) 1995 - 2006 Autodesk, Inc., and/or its licensors.  All
	// rights reserved.
	//
	// The coded instructions, statements, computer programs, and/or related
	// material (collectively the "Data") in these files contain unpublished
	// information proprietary to Autodesk, Inc. ("Autodesk") and/or its
	// licensors,  which is protected by U.S. and Canadian federal copyright law
	// and by international treaties.
	//
	// The Data may not be disclosed or distributed to third parties or be
	// copied or duplicated, in whole or in part, without the prior written
	// consent of Autodesk.
	//
	// The copyright notices in the Software and this entire statement,
	// including the above license grant, this restriction and the following
	// disclaimer, must be included in all copies of the Software, in whole
	// or in part, and all derivative works of the Software, unless such copies
	// or derivative works are solely in the form of machine-executable object
	// code generated by a source language processor.

	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
	// AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED
	// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF
	// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE,
	// OR ARISING FROM A COURSE OF DEALING, USAGE, OR TRADE PRACTICE. IN NO
	// EVENT WILL AUTODESK AND/OR ITS LICENSORS BE LIABLE FOR ANY LOST
	// REVENUES, DATA, OR PROFITS, OR SPECIAL, DIRECT, INDIRECT, OR
	// CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS LICENSORS HAS
	// BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.
	// ==========================================================================
	//+
	//
	// This header contains two macros that can be used to simplify the
	// creation of plug-in commands.
	//
	// ****************************************************************************

	MStatus assignShadingGroup(MDagModifier &dagMod, MObject transform, MString groupName)
	{
		MStatus st;

		// Get the name of the mesh node.
		//
		// We need to use an MFnDagNode rather than an MFnMesh because the mesh
		// is not fully realized at this point and would be rejected by MFnMesh.
		MFnDagNode  dagFn(transform);
		dagFn.setObject(dagFn.child(0));

		MString     meshName = dagFn.name();

		// Use the DAG modifier to put the mesh into a shading group
		MString     cmd("sets -e -fe ");
		cmd += groupName + " " + meshName;
		st = dagMod.commandToExecute(cmd);
		checkErr(st, "Could not add mesh to shading group");

		// Use the DAG modifier to select the new mesh.
		cmd = MString("select ") + meshName;
		st = dagMod.commandToExecute(cmd);
		checkErr(st, "Could not select new mesh");

		return st;
	}

	// Rename a transform and its shape so that they have the following names:
	//
	//      <baseName>#
	//      <baseName>Shape#
	//
	// where <baseName> is the string provided in the 'baseName' parameter and
	// '#' is an integer value which ensures the names are unique within the
	// scene.
	MStatus renameNodes(MDagModifier &dagMod, MObject transform, MString baseName)
	{
		MStatus st;

		//  Rename the transform to something we know no node will be using.
		st = dagMod.renameNode(transform, "polyPrimitiveCmdTemp");
		checkErr(st, "Could not rename transform node to temp name");

		//  Rename the mesh to the same thing but with 'Shape' on the end.
		MFnDagNode    dagFn(transform);

		st = dagMod.renameNode(dagFn.child(0), "polyPrimitiveCmdTempShape");
		checkErr(st, "Could not rename mesh node to temp name");

		//  Now that they are in the 'something/somethingShape' format, any
		//  changes we make to the name of the transform will automatically be
		//  propagated to the shape as well.
		//
		//  Maya will replace the '#' in the string below with a number which
		//  ensures uniqueness.
		MString  transformName = baseName + "#";
		st = dagMod.renameNode(transform, transformName);
		checkErr(st, "Could not rename transform node to final name");

		return st;
	}


	MStatus setMeshData(MDagModifier &dagMod, MObject transform, MObject dataWrapper)
	{
		MStatus st;

		// Get the mesh node.
		MFnDagNode  dagFn(transform);
		MObject     mesh = dagFn.child(0);

		// The mesh node has two geometry inputs: 'inMesh' and 'cachedInMesh'.
		// 'inMesh' is only used when it has an incoming connection, otherwise
		// 'cachedInMesh' is used. Unfortunately, the docs say that 'cachedInMesh'
		// is for internal use only and that changing it may render Maya
		// unstable.
		//
		// To get around that, we do the little dance below...

		// Use a temporary MDagModifier to create a temporary mesh attribute on
		// the node.
		MFnTypedAttribute  tAttr;
		MObject            tempAttr = tAttr.create("tempMesh", "tmpm", MFnData::kMesh);
		MDagModifier       tempMod;

		st = tempMod.addAttribute(mesh, tempAttr);
		checkErr(st, "Could not add 'tempMesh' attribute");

		st = tempMod.doIt();
		checkErr(st, "Could not commit addition of 'tempMesh' attribute");

		// Set the geometry data onto the temp attribute.
		dagFn.setObject(mesh);

		MPlug  tempPlug = dagFn.findPlug(tempAttr);

		st = tempPlug.setValue(dataWrapper);
		checkErr(st, "Could not set mesh geometry");

		// Use the temporary MDagModifier to connect the temp attribute to the
		// node's 'inMesh'.
		MPlug  inMeshPlug = dagFn.findPlug("inMesh");

		st = tempMod.connect(tempPlug, inMeshPlug);
		checkErr(st, "Could not connect 'tempMesh' to 'inMesh'");

		st = tempMod.doIt();
		checkErr(st, "Could not commit connection of 'tempMesh' to 'inMesh'");

		// Force the mesh to update by grabbing its output geometry.
		dagFn.findPlug("outMesh").asMObject();

		// Undo the temporary modifier.
		st = tempMod.undoIt();
		checkErr(st, "Could not undo 'tempMesh' attribute");

		return st;
	}

	////////////////////////////////////////////////////////////////
	// end borrowed (mostly!)
	////////////////////////////////////////////////////////////////

	MStatus ShapeFitting::fitShape(const MDagPath dagPath)
	{
		MStatus status;
		auto fDagPath = new MDagPath(dagPath);
		auto fMesh = new MFnMesh(*fDagPath, &status);
		// mesh data
		MPointArray         fVertexArray;
		MObjectArray        fPolygonSets;
		MObjectArray        fPolygonComponents;

		//If the shape is instanced then we need to determine which
		//instance this path refers to.
		//
		int instanceNum = 0;
		if (fDagPath->isInstanced())
			instanceNum = fDagPath->instanceNumber();

		//Get the connected sets and members - these will be used to determine texturing of different
		//faces
		//
		status = fMesh->getConnectedSetsAndMembers(instanceNum, fPolygonSets, fPolygonComponents, true);
		checkErr(status, "MFnMesh::getConnectedSetsAndMembers");

		// create fitting function
		//	defautl parameters
		FitParams_t params(fit_method, box_type);
		//	get function from algorithms library
		auto fit_fun = fitter_lib->get<void(Pts_t const &, PointsPusher_f, FitParams_t)>("detectFitPoly");

		//if there is more than one set, the last set simply consists of all 
		//polygons, so we won't include it
		//
		unsigned int setCount = fPolygonSets.length();
		if (setCount > 1) 
		{
			setCount--;
		}

		// loop through selected faces and create a fitting polygon shape
		//
		MIntArray faces;
		unsigned int i;
		for (i = 0; i < setCount; i++) 
		{
			MObject set = fPolygonSets[i];
			MObject comp = fPolygonComponents[i];
			MFnSet fnSet(set, &status);
			if (MS::kFailure == status) {
				MGlobal::displayError("MFnSet::MFnSet");
				continue;
			}
			//out << "dag pathname " << fDagPath->fullPathName()
			//	<< ", classname " << fDagPath->className()
			//	;

			//Make sure the set is a polygonal set.  If not, continue.
			MItMeshPolygon itMeshPolygon(*fDagPath, comp, &status);
			if ((MS::kFailure == status)) {
				MGlobal::displayError("MItMeshPolygon::MItMeshPolygon");
				continue;
			}

			//NOTE currently allowing only one-face shapes!
			if (itMeshPolygon.count() > 1)
			{
				MGlobal::displayError("Shape with more than one polygon/face! ignoring...");
				continue;
			}

			//add the current set's face indices to the faces array
			//
			faces.setLength(itMeshPolygon.count());
			unsigned int j = 0;
			for (itMeshPolygon.reset(); !itMeshPolygon.isDone(); itMeshPolygon.next()) 
			{
				// get points/vertices
				MPointArray point_array;
				itMeshPolygon.getPoints(point_array, MSpace::kWorld, &status);
				checkErr(status, "could not get polygon points!");

				// generate fitting shape
				{
					faceConnects.clear();
					faceCounts.clear();
					pa.clear();

					Pts_t in_pts;
					getShapePts(point_array, in_pts);

					// create pusher..
					//	NOTE backinserter would not work as it would still use the local heap
					//	convert from glm to MFloatPoint and append
					PointsPusher_f pusher = [this](Pts_t::value_type const &pt) { pa.append(MFloatPoint(pt.x, 0, pt.y)); };

					// get points!
					fit_fun(in_pts, pusher, params);

					// fill out data!
					{
						num_faces = 1;
						num_verts = pa.length();
						faceCounts.append(num_verts);
						for (j = 0; j < num_verts; ++j)
							faceConnects.append(j);
					}

					// Create a mesh data wrapper to hold the new geometry.
					MFnMeshData    dataFn;
					MObject        dataWrapper = dataFn.create();

					// Create the mesh geometry and put it into the wrapper.
					MFnMesh        meshFn;

					MObject        dataObj = meshFn.create(
												num_verts,
												num_faces,
												pa,
												faceCounts,
												faceConnects,
												dataWrapper,
													//NOTE use this if mesh transform node is not parenting the mesh: 
													//	MObject::kNullObj,
												&status);
					checkErr(status, "Mesh creation failed");

					// Use the DAG modifier to create an empty mesh node and its parent
					// transform.
					MObject transform = dagMod.createNode("mesh", MObject::kNullObj, &status);
					checkErr(status, "Empty mesh creation failed");

					// Commit the creation so that the transform and its child will be
					// valid below.
					status = dagMod.doIt();
					checkErr(status, "Could not commit creation of empty mesh");

					// At the moment we have a transform named something like 'transform1'
					// and a mesh named something like 'polySurfaceShape1'. Let's tidy that
					// up by renaming them as 'pPrimitive#' and 'pPrimitiveShape#', where
					// '#' is a number to ensure uniqueness.
					status = renameNodes(dagMod, transform, "pPrimitiveXYZ");
					if (!status) return status;

					//Commit the rename so that assignShadingGroup() can get the new name.
					status = dagMod.doIt();
					checkErr(status, "Could not commit renaming of nodes");

					// Assign the mesh to a shading group.
					status = assignShadingGroup(dagMod, transform, "initialShadingGroup");
					if (!status) return status;

					// Commit the changes.
					status = dagMod.doIt();
					checkErr(status, "Could not commit final changes");

					// Set the mesh node to use the geometry we created for it.
					status = setMeshData(dagMod, transform, dataWrapper);
					if (!status) return status;
				}
			}

			int db_ = 0xff;
		}


		delete fMesh;
		delete fDagPath;

		return MS::kSuccess;
	}

	void* ShapeFitting::creator() {
		return new ShapeFitting;
	}

} // end Maya

MStatus initializePlugin(MObject obj) 
{
	// algorithms are stored at this DyLib
	char const fitter_dylibname[] = "ShapeFittingDyLib.dll";

	// load algorithms library
	auto fitter_lib_path = getDyLibPath(fitter_dylibname);
	Maya::fitter_lib = boost::make_shared<dll::shared_library>(fitter_lib_path);
	MStatus st = Maya::fitter_lib.get() != nullptr ? MS::kSuccess : MS::kFailure;
	checkErr(st, "could not load algorithms library!");

	MFnPlugin plugin(obj, "Autodesk", "1.0", "Any");
	plugin.registerCommand("fitShape", Maya::ShapeFitting::creator);
	return MS::kSuccess;
}

MStatus uninitializePlugin(MObject obj) 
{	
	MFnPlugin plugin(obj);
	plugin.deregisterCommand("fitShape");

	// unload algorithms library
	Maya::fitter_lib.reset();

	return MS::kSuccess;
}
